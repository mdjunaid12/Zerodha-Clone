"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ndtk = _interopRequireDefault(require("ndtk"));

var _isFunction = _interopRequireDefault(require("lodash/isFunction"));

var _isString = _interopRequireDefault(require("lodash/isString"));

var _isNumber = _interopRequireDefault(require("lodash/isNumber"));

var _set = _interopRequireDefault(require("lodash/set"));

var _isPlainObject = _interopRequireDefault(require("lodash/isPlainObject"));

var _joi = _interopRequireDefault(require("@hapi/joi"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Load initializers
 */
function initialize(name, fn) {
  const server = this;

  _ndtk.default.assert((0, _isString.default)(name) && name.length !== 0, 'Initialize error: name is not a string');

  _ndtk.default.assert((0, _isFunction.default)(fn), `Initialize error: "${name}" has not a valid function`);

  fn(server);
}
/**
 * Execute Joi schema validations
 * and return parsed errors
 */


const validate = (value, schema) => {
  // Ensure schema is a valid object
  _ndtk.default.assert(schema && schema.isJoi || (0, _isPlainObject.default)(schema), 'Validate error: the schema provided is not a valid object');

  const validSchema = schema.isJoi ? schema : _joi.default.object(schema);

  const result = _joi.default.validate(value, validSchema, {
    stripUnknown: true,
    abortEarly: false
  });

  if (result.error) {
    const {
      details
    } = result.error;
    const error = details.reduce((obj, current) => {
      const {
        message,
        type,
        path
      } = current;
      (0, _set.default)(obj, path.map(item => (0, _isNumber.default)(item) ? `[${item}]` : item), {
        message: message.replace(/"/g, ''),
        type
      });
      return obj;
    }, {});
    return {
      error
    };
  }

  return {
    value: result.value
  };
};
/**
 * Execute body/params/query validations
 * and throw formatted error objects for possible errors
 * or append sanitized data to the request object
 */


const validateRequest = (source, schema) => {
  _ndtk.default.assert((0, _isString.default)(source), 'Validate error: source is not a string');

  const validSource = ['body', 'params', 'query'].includes(source);

  _ndtk.default.assert(validSource, 'Validate error: bad validation source, possible options are "body", "params", "query"');

  return (req, res, next) => {
    // First check for empty payloads
    if (!req[source]) throw _ndtk.default.httpError(422, {
      message: `Request ${source} data is missing`,
      type: 'VALIDATION'
    });
    const {
      value,
      error
    } = validate(req[source], schema);

    if (error) {
      throw _ndtk.default.httpError(422, {
        message: `Invalid request ${source} data`,
        type: 'VALIDATION',
        attributes: error
      });
    } // Reassign sanitized data back
    // to the request object ( with unknown keys removed )


    req[source] = value;
    next();
  };
};
/**
 * Format all caught errors
 * and return an http error object
 */


const generalErrorHandler = (err, req, res, next) => {
  // eslint-disable-line
  const {
    logger
  } = req.app; // For the purpose of logging at least a message

  err.message = err.message || 'Something bad happened';
  const {
    output
  } = err.isHttp ? err : _ndtk.default.httpError();
  if (output.status >= 500) logger.error(err);
  res.status(output.status);
  res.json(_objectSpread({}, output));
};
/**
 * Format not found routes
 * to return a 404 response
 */


const notFoundHandler = (req, res, next) => next(_ndtk.default.httpError(404));

var _default = {
  initialize,
  generalErrorHandler,
  notFoundHandler,
  validateRequest,
  validate
};
exports.default = _default;
//# sourceMappingURL=core.js.map