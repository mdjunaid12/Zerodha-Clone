{"version":3,"sources":["../../src/logger/formatter.js"],"names":["redact","util","inspect","styles","string","inspectOptions","colors","depth","compact","isError","e","stack","message","parseJSON","content","JSON","parse","reqStatus","info","status","color","chalk","red","green","yellow","reqExtras","time","size","type","sizeLabel","typeLabel","gray","reqRes","prettify","parsed","response","stringify","reqPayload","redactedBody","map","payload","lines","substring","indexOf","isReq","extras","method","path","redactedObject"],"mappings":";;;;;;;AAQA;;AACA;;AACA;;AACA;;;;AAXA;;;;;;;AAaA,MAAMA,MAAM,GAAG,4BAAG,YAAH,CAAf,C,CAEA;;AACAC,cAAKC,OAAL,CAAaC,MAAb,CAAoBC,MAApB,GAA6B,OAA7B;AACA,MAAMC,cAAc,GAAG;AAAEC,EAAAA,MAAM,EAAE,IAAV;AAAgBC,EAAAA,KAAK,EAAE,IAAvB;AAA6BC,EAAAA,OAAO,EAAE;AAAtC,CAAvB;;AAEA,MAAMC,OAAO,GAAGC,CAAC,IAAIA,CAAC,IAAIA,CAAC,CAACC,KAAP,IAAgBD,CAAC,CAACE,OAAlB,IAA6B,OAAOF,CAAC,CAACC,KAAT,KAAmB,QAAhD,IAA4D,OAAOD,CAAC,CAACE,OAAT,KAAqB,QAAtG;;AAEA,SAASC,SAAT,CAAmBT,MAAnB,EAA2B;AACzB,MAAI;AACF,UAAMU,OAAO,GAAGC,IAAI,CAACC,KAAL,CAAWZ,MAAX,CAAhB;AACA,QAAIU,OAAO,IAAI,OAAOA,OAAP,KAAmB,QAAlC,EAA4C,OAAOA,OAAP;AAC7C,GAHD,CAGE,OAAOJ,CAAP,EAAU,CAAE,CAJW,CAIV;;;AAEf,SAAON,MAAP;AACD,C,CAED;;;AACA,MAAMa,SAAS,GAAIC,IAAD,IAAU;AAC1B,QAAM;AAAEC,IAAAA;AAAF,MAAaD,IAAnB;AACA,MAAIE,KAAK,GAAGC,eAAMC,GAAlB;AAEA,MAAIH,MAAM,GAAG,GAAb,EAAkBC,KAAK,GAAGC,eAAME,KAAd;AAClB,MAAIJ,MAAM,IAAI,GAAV,IAAiBA,MAAM,GAAG,GAA9B,EAAmCC,KAAK,GAAGC,eAAMG,MAAd;AAEnC,SAAOJ,KAAK,CAACD,MAAD,CAAZ;AACD,CARD,C,CAUA;;;AACA,MAAMM,SAAS,GAAIP,IAAD,IAAU;AAC1B,QAAM;AAAEQ,IAAAA,IAAF;AAAQC,IAAAA,IAAR;AAAcC,IAAAA;AAAd,MAAuBV,IAA7B;AAEA,QAAMW,SAAS,GAAGF,IAAI,GAAI,KAAIA,IAAK,GAAb,GAAkB,EAAxC;AACA,QAAMG,SAAS,GAAGF,IAAI,GAAI,KAAIA,IAAK,EAAb,GAAiB,EAAvC;AACA,SAAOP,eAAMU,IAAN,CAAY,GAAEL,IAAK,MAAKG,SAAU,IAAGC,SAAU,EAA/C,CAAP;AACD,CAND,C,CAQA;;;AACA,MAAME,MAAM,GAAG,CAACd,IAAD,EAAOe,QAAP,KAAoB;AACjC;AACA,QAAMC,MAAM,GAAGrB,SAAS,CAACK,IAAI,CAACiB,QAAN,CAAxB;AACA,QAAM/B,MAAM,GAAG,uBAAS8B,MAAT,IAAmBnB,IAAI,CAACqB,SAAL,CAAeF,MAAf,CAAnB,GAA4CA,MAA3D;AACA,QAAMC,QAAQ,GAAGF,QAAQ,GAAGhC,cAAKC,OAAL,CAAagC,MAAb,EAAqB7B,cAArB,CAAH,GAA0CD,MAAnE;AAEA,SAAOiB,eAAMU,IAAN,CAAY,iBAAgBI,QAAS,EAArC,CAAP;AACD,CAPD,C,CASA;;;AACA,MAAME,UAAU,GAAG,CAACnB,IAAD,EAAOe,QAAP,KAAoB;AACrC,QAAMK,YAAY,GAAGtC,MAAM,CAACuC,GAAP,CAAWrB,IAAI,CAACsB,OAAhB,CAArB;AACA,QAAMA,OAAO,GAAGP,QAAQ,GAAGhC,cAAKC,OAAL,CAAaoC,YAAb,EAA2BjC,cAA3B,CAAH,GAAgDU,IAAI,CAACqB,SAAL,CAAeE,YAAf,CAAxE;AAEA,SAAOjB,eAAMU,IAAN,CAAY,gBAAeS,OAAQ,EAAnC,CAAP;AACD,CALD;AAOA;;;;;eAGe,CAACtB,IAAD,EAAO;AAAEe,EAAAA;AAAF,CAAP,KAAwB;AACrC;;;AAGA,MAAIxB,OAAO,CAACS,IAAD,CAAX,EAAmB;AACjB,UAAMN,OAAO,GAAGS,eAAMC,GAAN,CAAUJ,IAAI,CAACN,OAAf,CAAhB,CADiB,CAGjB;;;AACA,UAAM6B,KAAK,GAAGvB,IAAI,CAACP,KAAL,CAAW+B,SAAX,CAAqBxB,IAAI,CAACP,KAAL,CAAWgC,OAAX,CAAmB,IAAnB,IAA2B,CAAhD,CAAd;;AACA,UAAMhC,KAAK,GAAGU,eAAMC,GAAN,CAAUmB,KAAV,CAAd;;AAEA,WAAQ,GAAE7B,OAAQ,MAAKD,KAAM,EAA7B;AACD;AAED;;;;;AAGA,MAAI,uBAASO,IAAT,KAAkBA,IAAI,CAAC0B,KAA3B,EAAkC;AAChC,UAAMzB,MAAM,GAAGF,SAAS,CAACC,IAAD,CAAxB;AACA,UAAM2B,MAAM,GAAGpB,SAAS,CAACP,IAAD,CAAxB;AACA,UAAMiB,QAAQ,GAAGH,MAAM,CAACd,IAAD,EAAOe,QAAP,CAAvB;AACA,UAAMO,OAAO,GAAGH,UAAU,CAACnB,IAAD,EAAOe,QAAP,CAA1B;AAEA,UAAM;AACJa,MAAAA,MADI;AAEJC,MAAAA;AAFI,QAGF7B,IAHJ;AAKA,WAAQ,GAAE4B,MAAO,IAAGC,IAAK,KAAI5B,MAAO,KAAI0B,MAAO,IAAGL,OAAQ,IAAGL,QAAS,EAAtE;AACD;AAED;;;;;AAGA,MAAI,uBAASjB,IAAT,CAAJ,EAAoB;AAClB,UAAM8B,cAAc,GAAGhD,MAAM,CAACuC,GAAP,CAAWrB,IAAX,CAAvB;AACA,UAAMN,OAAO,GAAGqB,QAAQ,GAAGhC,cAAKC,OAAL,CAAa8C,cAAb,EAA6B3C,cAA7B,CAAH,GAAkDU,IAAI,CAACqB,SAAL,CAAeY,cAAf,CAA1E;AACA,WAAO3B,eAAMU,IAAN,CAAWnB,OAAX,CAAP;AACD;;AAED,SAAOM,IAAP;AACD,C","sourcesContent":["/**\n * Logger formatter\n *\n * @copyright Copyright (c) 2018, hugw.io\n * @author Hugo W - contact@hugw.io\n * @license MIT\n */\n\nimport chalk from 'chalk'\nimport util from 'util'\nimport isObject from 'lodash/isObject'\nimport rd from 'redact-secrets'\n\nconst redact = rd('[REDACTED]')\n\n// Update inspect colors\nutil.inspect.styles.string = 'white'\nconst inspectOptions = { colors: true, depth: null, compact: false }\n\nconst isError = e => e && e.stack && e.message && typeof e.stack === 'string' && typeof e.message === 'string'\n\nfunction parseJSON(string) {\n  try {\n    const content = JSON.parse(string)\n    if (content && typeof content === 'object') return content\n  } catch (e) {} // eslint-disable-line\n\n  return string\n}\n\n// Request status code\nconst reqStatus = (info) => {\n  const { status } = info\n  let color = chalk.red\n\n  if (status < 400) color = chalk.green\n  if (status >= 400 && status < 500) color = chalk.yellow\n\n  return color(status)\n}\n\n// Request extras (size / type / time)\nconst reqExtras = (info) => {\n  const { time, size, type } = info\n\n  const sizeLabel = size ? `/ ${size}b` : ''\n  const typeLabel = type ? `/ ${type}` : ''\n  return chalk.gray(`${time}ms ${sizeLabel} ${typeLabel}`)\n}\n\n// Request response\nconst reqRes = (info, prettify) => {\n  // Parse response if JSON\n  const parsed = parseJSON(info.response)\n  const string = isObject(parsed) ? JSON.stringify(parsed) : parsed\n  const response = prettify ? util.inspect(parsed, inspectOptions) : string\n\n  return chalk.gray(`\\n Response → ${response}`)\n}\n\n// Request payload\nconst reqPayload = (info, prettify) => {\n  const redactedBody = redact.map(info.payload)\n  const payload = prettify ? util.inspect(redactedBody, inspectOptions) : JSON.stringify(redactedBody)\n\n  return chalk.gray(`\\n Payload → ${payload}`)\n}\n\n/**\n * Main formatter\n */\nexport default (info, { prettify }) => {\n  /**\n   * Errors\n   */\n  if (isError(info)) {\n    const message = chalk.red(info.message)\n\n    // Remove first line (duplicate of message)\n    const lines = info.stack.substring(info.stack.indexOf('\\n') + 1)\n    const stack = chalk.red(lines)\n\n    return `${message} \\n${stack}`\n  }\n\n  /**\n   * Request\n   */\n  if (isObject(info) && info.isReq) {\n    const status = reqStatus(info)\n    const extras = reqExtras(info)\n    const response = reqRes(info, prettify)\n    const payload = reqPayload(info, prettify)\n\n    const {\n      method,\n      path,\n    } = info\n\n    return `${method} ${path}  ${status}  ${extras} ${payload} ${response}`\n  }\n\n  /**\n   * Objects\n   */\n  if (isObject(info)) {\n    const redactedObject = redact.map(info)\n    const message = prettify ? util.inspect(redactedObject, inspectOptions) : JSON.stringify(redactedObject)\n    return chalk.gray(message)\n  }\n\n  return info\n}\n"],"file":"formatter.js"}