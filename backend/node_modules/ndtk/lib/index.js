"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.httpError = exports.config = exports.isDir = exports.req = exports.ccd = exports.assert = exports.IS_QA = exports.IS_PROD = exports.IS_STAG = exports.IS_TEST = exports.IS_DEV = exports.ENV = void 0;

var _path = _interopRequireDefault(require("path"));

var _fs = _interopRequireDefault(require("fs"));

var _merge = _interopRequireDefault(require("lodash/merge"));

var _snakeCase = _interopRequireDefault(require("lodash/snakeCase"));

var _toUpper = _interopRequireDefault(require("lodash/toUpper"));

var _statuses = _interopRequireDefault(require("statuses"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

/**
 * Environment
 * utility functions
 */
const DEV = 'development';
const STAG = 'staging';
const TEST = 'test';
const PROD = 'production';
const QA = 'qa';
const ENV = process.env.NODE_ENV || DEV;
exports.ENV = ENV;
const IS_DEV = ENV === DEV;
exports.IS_DEV = IS_DEV;
const IS_TEST = ENV === TEST;
exports.IS_TEST = IS_TEST;
const IS_STAG = ENV === STAG;
exports.IS_STAG = IS_STAG;
const IS_PROD = ENV === PROD;
exports.IS_PROD = IS_PROD;
const IS_QA = ENV === QA;
/**
 * Executes simple assertions and
 * throw errors in negative cases
 */

exports.IS_QA = IS_QA;

const assert = (condition, content) => {
  if (condition) return;
  let error;

  if (content instanceof Error) {
    error = content;
  } else if (typeof content === 'string') {
    error = new Error(content);
  } else {
    error = new Error('Something went wrong.');
  } // Omits all frames above "assert" from the generated stack trace


  Error.captureStackTrace(error, assert);
  throw error;
};
/**
 * Current caller directory
 * @link https://github.com/stefanpenner/get-caller-file/blob/master/index.js
 */


exports.assert = assert;

const ccd = () => {
  const oldPrepareStackTrace = Error.prepareStackTrace;

  Error.prepareStackTrace = (err, stack) => stack;

  const {
    stack
  } = new Error();
  Error.prepareStackTrace = oldPrepareStackTrace; // stack[0] holds this file
  // stack[1] holds where this function was called
  // stack[2] holds the file we're interested in

  const line = stack[2];
  return !!line && _path.default.dirname(line.getFileName());
};
/**
 * Require optional modules without
 * throwing unwanted exceptions
 */


exports.ccd = ccd;

const req = (name, defaultOnly = true) => {
  try {
    const dir = _path.default.resolve(ccd(), name);

    const module = require(dir); // eslint-disable-line global-require, import/no-dynamic-require


    return defaultOnly ? module.default : module;
  } catch (err) {
    return null;
  }
};
/**
 * Verifies if current path
 * is a valid directory without
 * throwing unwanted exceptions
 */


exports.req = req;

const isDir = dir => {
  try {
    const stats = _fs.default.statSync(dir);

    return stats.isDirectory();
  } catch (e) {
    return false;
  }
};
/**
 * Generates configuration objects based
 * on the current environment
 */


exports.isDir = isDir;

const config = (object, defaults) => (0, _merge.default)({}, defaults && defaults.default, object && object.default, defaults && defaults[ENV], object && object[ENV]);
/**
 * HTTP-friendly error objects
 */


exports.config = config;

const httpError = (code, meta = {}) => {
  const {
    message: customMessage,
    type: customType
  } = meta,
        rest = _objectWithoutProperties(meta, ["message", "type"]);

  const status = _statuses.default[code] ? code : 500;
  const message = customMessage || _statuses.default[status];
  const type = customType || (0, _toUpper.default)((0, _snakeCase.default)(_statuses.default[status]));
  const error = new Error(message);
  error.isHttp = true;
  error.output = _objectSpread({
    status,
    message,
    type
  }, rest); // Omits all frames above "httpError" from the generated stack trace

  Error.captureStackTrace(error, httpError);
  return error;
};

exports.httpError = httpError;
var _default = {
  assert,
  ccd,
  req,
  isDir,
  config,
  merge: _merge.default,
  httpError
};
exports.default = _default;
//# sourceMappingURL=index.js.map